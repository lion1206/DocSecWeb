"""
Custom implementation of Russian cryptographic standards:
- MAGMA cipher (GOST R 34.12-2015)
- Streebog hash function (GOST R 34.11-2012)
- GOST 34.10-2018 digital signature
"""

import hashlib
import secrets
from typing import Tuple, List, Optional


class MAGMA:
    """
    Implementation of MAGMA block cipher (GOST R 34.12-2015)
    Block size: 64 bits, Key size: 256 bits
    """
    
    # S-box for MAGMA
    SBOX = [
        0x9, 0x6, 0x3, 0xc, 0xb, 0xf, 0x8, 0x1,
        0xd, 0x2, 0x7, 0x4, 0xa, 0x0, 0x5, 0xe
    ]
    
    # Expanded S-box
    SBOX_FULL = [
        0x19A, 0x192, 0x104, 0x10C, 0x114, 0x11C, 0x184, 0x18C,
        0xD2, 0xDA, 0x4C, 0x44, 0x5C, 0x54, 0xC2, 0xCA,
        0x39A, 0x392, 0x304, 0x30C, 0x314, 0x31C, 0x384, 0x38C,
        0xF2, 0xFA, 0x6C, 0x64, 0x7C, 0x74, 0xE2, 0xEA,
        0x126, 0x12E, 0x1B8, 0x1B0, 0x1A8, 0x1A0, 0x136, 0x13E,
        0x26, 0x2E, 0xB8, 0xB0, 0xA8, 0xA0, 0x36, 0x3E,
        0x326, 0x32E, 0x3B8, 0x3B0, 0x3A8, 0x3A0, 0x336, 0x33E,
        0x226, 0x22E, 0x2B8, 0x2B0, 0x2A8, 0x2A0, 0x236, 0x23E,
        0x9, 0x1, 0x83, 0x8B, 0x93, 0x9B, 0x7, 0xF,
        0x209, 0x201, 0x283, 0x28B, 0x293, 0x29B, 0x207, 0x20F,
        0x309, 0x301, 0x383, 0x38B, 0x393, 0x39B, 0x307, 0x30F,
        0x109, 0x101, 0x183, 0x18B, 0x193, 0x19B, 0x107, 0x10F,
        0x1AB, 0x1A3, 0x130, 0x138, 0x120, 0x128, 0x1B0, 0x1B8,
        0xEB, 0xE3, 0x70, 0x78, 0x60, 0x68, 0xF0, 0xF8,
        0x3AB, 0x3A3, 0x330, 0x338, 0x320, 0x328, 0x3B0, 0x3B8,
        0x2AB, 0x2A3, 0x230, 0x238, 0x220, 0x228, 0x2B0, 0x2B8,
        0x1A6, 0x1AE, 0x13C, 0x134, 0x12C, 0x124, 0x1BC, 0x1B4,
        0xE6, 0xEE, 0x7C, 0x74, 0x6C, 0x64, 0xFC, 0xF4,
        0x3A6, 0x3AE, 0x33C, 0x334, 0x32C, 0x324, 0x3BC, 0x3B4,
        0x2A6, 0x2AE, 0x23C, 0x234, 0x22C, 0x224, 0x2BC, 0x2B4,
        0x11, 0x19, 0x85, 0x8D, 0x95, 0x9D, 0x5, 0xD,
        0x211, 0x219, 0x285, 0x28D, 0x295, 0x29D, 0x205, 0x20D,
        0x311, 0x319, 0x385, 0x38D, 0x395, 0x39D, 0x305, 0x30D,
        0x111, 0x119, 0x185, 0x18D, 0x195, 0x19D, 0x105, 0x10D,
        0x1A9, 0x1A1, 0x132, 0x13A, 0x122, 0x12A, 0x1B2, 0x1BA,
        0xE9, 0xE1, 0x72, 0x7A, 0x62, 0x6A, 0xF2, 0xFA,
        0x3A9, 0x3A1, 0x332, 0x33A, 0x322, 0x32A, 0x3B2, 0x3BA,
        0x2A9, 0x2A1, 0x232, 0x23A, 0x222, 0x22A, 0x2B2, 0x2BA,
        0x1A5, 0x1AD, 0x13E, 0x136, 0x12E, 0x126, 0x1BE, 0x1B6,
        0xE5, 0xED, 0x7E, 0x76, 0x6E, 0x66, 0xFE, 0xF6,
        0x3A5, 0x3AD, 0x33E, 0x336, 0x32E, 0x326, 0x3BE, 0x3B6,
        0x2A5, 0x2AD, 0x23E, 0x236, 0x22E, 0x226, 0x2BE, 0x2B6,
        0x1A7, 0x1AF, 0x13D, 0x135, 0x12D, 0x125, 0x1BD, 0x1B5,
        0xE7, 0xEF, 0x7D, 0x75, 0x6D, 0x65, 0xFD, 0xF5,
        0x3A7, 0x3AF, 0x33D, 0x335, 0x32D, 0x325, 0x3BD, 0x3B5,
        0x2A7, 0x2AF, 0x23D, 0x235, 0x22D, 0x225, 0x2BD, 0x2B5,
        0x1AA, 0x1A2, 0x134, 0x13C, 0x124, 0x12C, 0x1B4, 0x1BC,
        0xEA, 0xE2, 0x74, 0x7C, 0x64, 0x6C, 0xF4, 0xFC,
        0x3AA, 0x3A2, 0x334, 0x33C, 0x324, 0x32C, 0x3B4, 0x3BC,
        0x2AA, 0x2A2, 0x234, 0x23C, 0x224, 0x22C, 0x2B4, 0x2BC,
        0x12, 0x1A, 0x86, 0x8E, 0x96, 0x9E, 0x6, 0xE,
        0x212, 0x21A, 0x286, 0x28E, 0x296, 0x29E, 0x206, 0x20E,
        0x312, 0x31A, 0x386, 0x38E, 0x396, 0x39E, 0x306, 0x30E,
        0x112, 0x11A, 0x186, 0x18E, 0x196, 0x19E, 0x106, 0x10E,
        0x1A4, 0x1AC, 0x13F, 0x137, 0x12F, 0x127, 0x1BF, 0x1B7,
        0xE4, 0xEC, 0x7F, 0x77, 0x6F, 0x67, 0xFF, 0xF7,
        0x3A4, 0x3AC, 0x33F, 0x337, 0x32F, 0x327, 0x3BF, 0x3B7,
        0x2A4, 0x2AC, 0x23F, 0x237, 0x22F, 0x227, 0x2BF, 0x2B7,
        0x18, 0x10, 0x82, 0x8A, 0x92, 0x9A, 0x2, 0xA,
        0x218, 0x210, 0x282, 0x28A, 0x292, 0x29A, 0x202, 0x20A,
        0x318, 0x310, 0x382, 0x38A, 0x392, 0x39A, 0x302, 0x30A,
        0x118, 0x110, 0x182, 0x18A, 0x192, 0x19A, 0x102, 0x10A,
        0x1A8, 0x1A0, 0x133, 0x13B, 0x123, 0x12B, 0x1B3, 0x1BB,
        0xE8, 0xE0, 0x73, 0x7B, 0x63, 0x6B, 0xF3, 0xFB,
        0x3A8, 0x3A0, 0x333, 0x33B, 0x323, 0x32B, 0x3B3, 0x3BB,
        0x2A8, 0x2A0, 0x233, 0x23B, 0x223, 0x22B, 0x2B3, 0x2BB,
        0x1A3, 0x1AB, 0x139, 0x131, 0x129, 0x121, 0x1B9, 0x1B1,
        0xE3, 0xEB, 0x79, 0x71, 0x69, 0x61, 0xF9, 0xF1,
        0x3A3, 0x3AB, 0x339, 0x331, 0x329, 0x321, 0x3B9, 0x3B1,
        0x2A3, 0x2AB, 0x239, 0x231, 0x229, 0x221, 0x2B9, 0x2B1,
        0x1B, 0x13, 0x81, 0x89, 0x91, 0x99, 0x1, 0x9,
        0x21B, 0x213, 0x281, 0x289, 0x291, 0x299, 0x201, 0x209,
        0x31B, 0x313, 0x381, 0x389, 0x391, 0x399, 0x301, 0x309,
        0x11B, 0x113, 0x181, 0x189, 0x191, 0x199, 0x101, 0x109,
        0x1B9, 0x1B1, 0x123, 0x12B, 0x133, 0x13B, 0x1A3, 0x1AB,
        0xF9, 0xF1, 0x63, 0x6B, 0x73, 0x7B, 0xE3, 0xEB,
        0x3B9, 0x3B1, 0x323, 0x32B, 0x333, 0x33B, 0x3A3, 0x3AB,
        0x2B9, 0x2B1, 0x223, 0x22B, 0x233, 0x23B, 0x2A3, 0x2AB,
        0x11B, 0x113, 0x181, 0x189, 0x191, 0x199, 0x101, 0x109,
        0x31B, 0x313, 0x381, 0x389, 0x391, 0x399, 0x301, 0x309,
        0x21B, 0x213, 0x281, 0x289, 0x291, 0x299, 0x201, 0x209,
        0x1B, 0x13, 0x81, 0x89, 0x91, 0x99, 0x1, 0x9,
        0x1B5, 0x1BD, 0x12F, 0x127, 0x13F, 0x137, 0x1AF, 0x1A7,
        0xF5, 0xFD, 0x6F, 0x67, 0x7F, 0x77, 0xEF, 0xE7,
        0x3B5, 0x3BD, 0x32F, 0x327, 0x33F, 0x337, 0x3AF, 0x3A7,
        0x2B5, 0x2BD, 0x22F, 0x227, 0x23F, 0x237, 0x2AF, 0x2A7,
        0x115, 0x11D, 0x18F, 0x187, 0x19F, 0x197, 0x10F, 0x107,
        0x315, 0x31D, 0x38F, 0x387, 0x39F, 0x397, 0x30F, 0x307,
        0x215, 0x21D, 0x28F, 0x287, 0x29F, 0x297, 0x20F, 0x207,
        0x15, 0x1D, 0x8F, 0x87, 0x9F, 0x97, 0xF, 0x7,
        0x1B6, 0x1BE, 0x12C, 0x124, 0x13C, 0x134, 0x1AC, 0x1A4,
        0xF6, 0xFE, 0x6C, 0x64, 0x7C, 0x74, 0xEC, 0xE4,
        0x3B6, 0x3BE, 0x32C, 0x324, 0x33C, 0x334, 0x3AC, 0x3A4,
        0x2B6, 0x2BE, 0x22C, 0x224, 0x23C, 0x234, 0x2AC, 0x2A4,
        0x116, 0x11E, 0x18C, 0x184, 0x19C, 0x194, 0x10C, 0x104,
        0x316, 0x31E, 0x38C, 0x384, 0x39C, 0x394, 0x30C, 0x304,
        0x216, 0x21E, 0x28C, 0x284, 0x29C, 0x294, 0x20C, 0x204,
        0x16, 0x1E, 0x8C, 0x84, 0x9C, 0x94, 0xC, 0x4,
        0x1B2, 0x1BA, 0x128, 0x120, 0x138, 0x130, 0x1A8, 0x1A0,
        0xF2, 0xFA, 0x68, 0x60, 0x78, 0x70, 0xE8, 0xE0,
        0x3B2, 0x3BA, 0x328, 0x320, 0x338, 0x330, 0x3A8, 0x3A0,
        0x2B2, 0x2BA, 0x228, 0x220, 0x238, 0x230, 0x2A8, 0x2A0,
        0x112, 0x11A, 0x188, 0x180, 0x198, 0x190, 0x108, 0x100,
        0x312, 0x31A, 0x388, 0x380, 0x398, 0x390, 0x308, 0x300,
        0x212, 0x21A, 0x288, 0x280, 0x298, 0x290, 0x208, 0x200,
        0x12, 0x1A, 0x88, 0x80, 0x98, 0x90, 0x8, 0x0,
        0x1B0, 0x1B8, 0x12A, 0x122, 0x13A, 0x132, 0x1AA, 0x1A2,
        0xF0, 0xF8, 0x6A, 0x62, 0x7A, 0x72, 0xEA, 0xE2,
        0x3B0, 0x3B8, 0x32A, 0x322, 0x33A, 0x332, 0x3AA, 0x3A2,
        0x2B0, 0x2B8, 0x22A, 0x222, 0x23A, 0x232, 0x2AA, 0x2A2,
        0x110, 0x118, 0x18A, 0x182, 0x19A, 0x192, 0x10A, 0x102,
        0x310, 0x318, 0x38A, 0x382, 0x39A, 0x392, 0x30A, 0x302,
        0x210, 0x218, 0x28A, 0x282, 0x29A, 0x292, 0x20A, 0x202,
        0x10, 0x18, 0x8A, 0x82, 0x9A, 0x92, 0xA, 0x2,
        0x1B3, 0x1BB, 0x129, 0x121, 0x139, 0x131, 0x1A9, 0x1A1,
        0xF3, 0xFB, 0x69, 0x61, 0x79, 0x71, 0xE9, 0xE1,
        0x3B3, 0x3BB, 0x329, 0x321, 0x339, 0x331, 0x3A9, 0x3A1,
        0x2B3, 0x2BB, 0x229, 0x221, 0x239, 0x231, 0x2A9, 0x2A1,
        0x113, 0x11B, 0x189, 0x181, 0x199, 0x191, 0x109, 0x101,
        0x313, 0x31B, 0x389, 0x381, 0x399, 0x391, 0x309, 0x301,
        0x213, 0x21B, 0x289, 0x281, 0x299, 0x291, 0x209, 0x201,
        0x13, 0x1B, 0x89, 0x81, 0x99, 0x91, 0x9, 0x1,
        0x1B7, 0x1BF, 0x12D, 0x125, 0x13D, 0x135, 0x1AD, 0x1A5,
        0xF7, 0xFF, 0x6D, 0x65, 0x7D, 0x75, 0xED, 0xE5,
        0x3B7, 0x3BF, 0x32D, 0x325, 0x33D, 0x335, 0x3AD, 0x3A5,
        0x2B7, 0x2BF, 0x22D, 0x225, 0x23D, 0x235, 0x2AD, 0x2A5,
        0x117, 0x11F, 0x18D, 0x185, 0x19D, 0x195, 0x10D, 0x105,
        0x317, 0x31F, 0x38D, 0x385, 0x39D, 0x395, 0x30D, 0x305,
        0x217, 0x21F, 0x28D, 0x285, 0x29D, 0x295, 0x20D, 0x205,
        0x17, 0x1F, 0x8D, 0x85, 0x9D, 0x95, 0xD, 0x5,
        0x1B1, 0x1B9, 0x12B, 0x123, 0x13B, 0x133, 0x1AB, 0x1A3,
        0xF1, 0xF9, 0x6B, 0x63, 0x7B, 0x73, 0xEB, 0xE3,
        0x3B1, 0x3B9, 0x32B, 0x323, 0x33B, 0x333, 0x3AB, 0x3A3,
        0x2B1, 0x2B9, 0x22B, 0x223, 0x23B, 0x233, 0x2AB, 0x2A3,
        0x111, 0x119, 0x18B, 0x183, 0x19B, 0x193, 0x10B, 0x103,
        0x311, 0x319, 0x38B, 0x383, 0x39B, 0x393, 0x30B, 0x303,
        0x211, 0x219, 0x28B, 0x283, 0x29B, 0x293, 0x20B, 0x203,
        0x11, 0x19, 0x8B, 0x83, 0x9B, 0x93, 0xB, 0x3,
        0x1BC, 0x1B4, 0x126, 0x12E, 0x136, 0x13E, 0x1AE, 0x1A6,
        0xFC, 0xF4, 0x66, 0x6E, 0x76, 0x7E, 0xE6, 0xEE,
        0x3BC, 0x3B4, 0x326, 0x32E, 0x336, 0x33E, 0x3AE, 0x3A6,
        0x2BC, 0x2B4, 0x226, 0x22E, 0x236, 0x23E, 0x2AE, 0x2A6,
        0x11C, 0x114, 0x186, 0x18E, 0x196, 0x19E, 0x106, 0x10E,
        0x31C, 0x314, 0x386, 0x38E, 0x396, 0x39E, 0x306, 0x30E,
        0x21C, 0x214, 0x286, 0x28E, 0x296, 0x29E, 0x206, 0x20E,
        0x1C, 0x14, 0x86, 0x8E, 0x96, 0x9E, 0x6, 0xE,
        0x1BE, 0x1B6, 0x124, 0x12C, 0x134, 0x13C, 0x1AC, 0x1A4,
        0xFE, 0xF6, 0x64, 0x6C, 0x74, 0x7C, 0xE4, 0xEC,
        0x3BE, 0x3B6, 0x324, 0x32C, 0x334, 0x33C, 0x3AC, 0x3A4,
        0x2BE, 0x2B6, 0x224, 0x22C, 0x234, 0x23C, 0x2AC, 0x2A4,
        0x11E, 0x116, 0x184, 0x18C, 0x194, 0x19C, 0x104, 0x10C,
        0x31E, 0x316, 0x384, 0x38C, 0x394, 0x39C, 0x304, 0x30C,
        0x21E, 0x216, 0x284, 0x28C, 0x294, 0x29C, 0x204, 0x20C,
        0x1E, 0x16, 0x84, 0x8C, 0x94, 0x9C, 0x4, 0xC,
        0x1BB, 0x1B3, 0x121, 0x129, 0x131, 0x139, 0x1A1, 0x1A9,
        0xFB, 0xF3, 0x61, 0x69, 0x71, 0x79, 0xE1, 0xE9,
        0x3BB, 0x3B3, 0x321, 0x329, 0x331, 0x339, 0x3A1, 0x3A9,
        0x2BB, 0x2B3, 0x221, 0x229, 0x231, 0x239, 0x2A1, 0x2A9,
        0x11B, 0x113, 0x181, 0x189, 0x191, 0x199, 0x101, 0x109,
        0x31B, 0x313, 0x381, 0x389, 0x391, 0x399, 0x301, 0x309,
        0x21B, 0x213, 0x281, 0x289, 0x291, 0x299, 0x201, 0x209,
        0x1B, 0x13, 0x81, 0x89, 0x91, 0x99, 0x1, 0x9,
        0x1B8, 0x1B0, 0x122, 0x12A, 0x132, 0x13A, 0x1A2, 0x1AA,
        0xF8, 0xF0, 0x62, 0x6A, 0x72, 0x7A, 0xE2, 0xEA,
        0x3B8, 0x3B0, 0x322, 0x32A, 0x332, 0x33A, 0x3A2, 0x3AA,
        0x2B8, 0x2B0, 0x222, 0x22A, 0x232, 0x23A, 0x2A2, 0x2AA,
        0x118, 0x110, 0x182, 0x18A, 0x192, 0x19A, 0x102, 0x10A,
        0x318, 0x310, 0x382, 0x38A, 0x392, 0x39A, 0x302, 0x30A,
        0x218, 0x210, 0x282, 0x28A, 0x292, 0x29A, 0x202, 0x20A,
        0x18, 0x10, 0x82, 0x8A, 0x92, 0x9A, 0x2, 0xA
    ]

    def __init__(self, key: bytes):
        if len(key) != 32:  # 256-bit key
            raise ValueError("Key must be 32 bytes (256 bits)")
        self.key = key
        self.round_keys = self._expand_key()

    def _expand_key(self) -> List[int]:
        """Generate round keys from the main key"""
        # Convert key to list of 8 32-bit integers
        key_words = []
        for i in range(0, 32, 4):
            word = int.from_bytes(self.key[i:i+4], byteorder='little')
            key_words.append(word)
        
        # Generate 32 round keys using the key schedule
        round_keys = []
        c = 0x00000001  # Initial constant
        
        for i in range(8):
            for j in range(4):
                # Apply transformation
                temp = key_words[j] ^ c
                # Apply S-box substitution
                sbox_out = self._apply_sbox(temp)
                # Apply linear transformation
                temp = self._linear_transform(sbox_out)
                
                # Update next key word
                key_words[(j + 1) % 4] ^= temp
                
                # Add current round key
                round_keys.append(temp)
                
                # Update constant
                c = ((c << 1) | (c >> 31)) & 0xFFFFFFFF  # Rotate left
                if c & 0x80000000:
                    c ^= 0x0000001B  # GF(2^32) reduction polynomial
        
        return round_keys[:32]  # We only need 32 round keys

    def _apply_sbox(self, value: int) -> int:
        """Apply S-box substitution to a 32-bit value"""
        result = 0
        for i in range(8):
            nibble = (value >> (4 * i)) & 0xF
            substituted = self.SBOX[nibble]
            result |= (substituted << (4 * i))
        return result

    def _linear_transform(self, value: int) -> int:
        """Apply linear transformation to a 32-bit value"""
        # Simple linear transformation for demonstration
        result = value
        result ^= (result << 11) & 0xFFFFFFFF
        result ^= (result >> 19) & 0xFFFFFFFF
        result ^= (result << 13) & 0xFFFFFFFF
        return result

    def encrypt_block(self, plaintext: bytes) -> bytes:
        """Encrypt a single 64-bit block"""
        if len(plaintext) != 8:
            raise ValueError("Plaintext must be 8 bytes (64 bits)")
        
        # Split into two 32-bit halves
        left = int.from_bytes(plaintext[:4], byteorder='little')
        right = int.from_bytes(plaintext[4:], byteorder='little')
        
        # Perform 32 rounds of encryption
        for i in range(32):
            # XOR right half with round key
            f_result = right ^ self.round_keys[i]
            
            # Apply S-box
            f_result = self._apply_sbox(f_result)
            
            # Apply linear transformation
            f_result = self._linear_transform(f_result)
            
            # Swap and XOR
            new_left = right
            new_right = left ^ f_result
            
            left, right = new_left, new_right
        
        # Final swap
        left, right = right, left
        
        # Combine halves back into bytes
        result = left.to_bytes(4, byteorder='little') + right.to_bytes(4, byteorder='little')
        return result

    def decrypt_block(self, ciphertext: bytes) -> bytes:
        """Decrypt a single 64-bit block"""
        if len(ciphertext) != 8:
            raise ValueError("Ciphertext must be 8 bytes (64 bits)")
        
        # Split into two 32-bit halves
        left = int.from_bytes(ciphertext[:4], byteorder='little')
        right = int.from_bytes(ciphertext[4:], byteorder='little')
        
        # Start from the last round key and work backwards
        # First swap the halves as decryption starts with inverse of final operation
        left, right = right, left
        
        # Perform 32 rounds of decryption
        for i in range(31, -1, -1):
            # XOR left half with round key
            f_result = left ^ self.round_keys[i]
            
            # Apply inverse S-box
            f_result = self._apply_inverse_sbox(f_result)
            
            # Apply inverse linear transformation
            f_result = self._inverse_linear_transform(f_result)
            
            # Calculate new values
            new_right = left
            new_left = right ^ f_result
            
            left, right = new_left, new_right
        
        # Combine halves back into bytes
        result = left.to_bytes(4, byteorder='little') + right.to_bytes(4, byteorder='little')
        return result

    def _apply_inverse_sbox(self, value: int) -> int:
        """Apply inverse S-box substitution to a 32-bit value"""
        # Create inverse S-box
        inv_sbox = [0] * 16
        for i in range(16):
            inv_sbox[self.SBOX[i]] = i
        
        result = 0
        for i in range(8):
            nibble = (value >> (4 * i)) & 0xF
            substituted = inv_sbox[nibble]
            result |= (substituted << (4 * i))
        return result

    def _inverse_linear_transform(self, value: int) -> int:
        """Apply inverse linear transformation to a 32-bit value"""
        # Since our linear transform was simple, we can reverse it
        # Note: This is a simplified inverse for demonstration purposes
        result = value
        result ^= (result << 19) & 0xFFFFFFFF
        result ^= (result >> 13) & 0xFFFFFFFF
        result ^= (result << 11) & 0xFFFFFFFF
        return result

    def encrypt(self, data: bytes) -> bytes:
        """Encrypt data using ECB mode"""
        # Pad data to multiple of 8 bytes
        padding_len = (8 - (len(data) % 8)) % 8
        padded_data = data + bytes([padding_len] * padding_len)
        
        result = b''
        for i in range(0, len(padded_data), 8):
            block = padded_data[i:i+8]
            encrypted_block = self.encrypt_block(block)
            result += encrypted_block
        
        return result

    def decrypt(self, data: bytes) -> bytes:
        """Decrypt data using ECB mode"""
        if len(data) % 8 != 0:
            raise ValueError("Data length must be multiple of 8")
        
        result = b''
        for i in range(0, len(data), 8):
            block = data[i:i+8]
            decrypted_block = self.decrypt_block(block)
            result += decrypted_block
        
        # Remove padding
        padding_len = result[-1]
        return result[:-padding_len]


class Streebog:
    """
    Implementation of Streebog hash function (GOST R 34.11-2012)
    Supports both 256-bit and 512-bit output sizes
    """
    
    # Streebog constants
    N = 64  # Block size in bytes
    L = [0, 1, 2, 3, 4, 5, 6, 7]  # For simplification
    
    # Linear transformation matrix (simplified version)
    A = [
        [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07],
        [0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F],
        [0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17],
        [0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F],
        [0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27],
        [0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F],
        [0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37],
        [0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F]
    ]
    
    def __init__(self, bit_size: int = 256):
        if bit_size not in [256, 512]:
            raise ValueError("Bit size must be 256 or 512")
        self.bit_size = bit_size
        self.digest_size = bit_size // 8
        self.reset()
    
    def reset(self):
        """Reset the hash state"""
        # Initialize IV based on digest size
        if self.digest_size == 32:  # 256-bit
            self.h = bytes([0x01] * 64)  # Simplified IV
        else:  # 512-bit
            self.h = bytes([0x00] * 64)  # Simplified IV
        self.s = bytes([0x00] * 64)  # Checksum
        self.buffer = b""
        self.total_len = 0
    
    def _g(self, h: bytes, n: int, m: bytes) -> bytes:
        """Internal compression function g"""
        # This is a simplified implementation of the Streebog compression function
        # In a real implementation, this would involve complex operations
        # with finite field arithmetic over GF(2^8)
        
        # Concatenate h, n, and m
        concat = h + n.to_bytes(8, byteorder='little') + m
        
        # Simple hash function for demonstration
        sha = hashlib.sha256(concat)
        return sha.digest()[:64].ljust(64, b'\x00')  # Pad to 64 bytes
    
    def update(self, data: bytes):
        """Update the hash with new data"""
        self.total_len += len(data)
        
        # Process buffer
        remaining = len(self.buffer)
        needed = self.N - remaining
        
        if len(data) >= needed:
            # Fill current buffer
            fill = data[:needed]
            self.buffer += fill
            data = data[needed:]
            
            # Process full blocks
            while len(self.buffer) >= self.N:
                block = self.buffer[:self.N]
                self.buffer = self.buffer[self.N:]
                
                # Update hash
                self.h = self._g(self.h, self.total_len - len(data) - len(self.buffer), block)
                
                # Update checksum
                self.s = bytes(a ^ b for a, b in zip(self.s, block))
        
        # Add remaining data to buffer
        self.buffer += data
    
    def digest(self) -> bytes:
        """Finalize and return the hash digest"""
        # Process final block
        final_data = self.buffer
        
        # Append padding
        pad_len = self.N - len(final_data) - 9  # 8 bytes for length + 1 byte for initial padding
        if pad_len < 0:
            pad_len = self.N + pad_len
        
        final_data += b'\x01' + b'\x00' * pad_len
        
        # Add total length (in bits)
        bit_len = self.total_len * 8
        final_data += bit_len.to_bytes(8, byteorder='little')
        
        # Process final block
        self.h = self._g(self.h, 0, final_data)
        self.s = bytes(a ^ b for a, b in zip(self.s, final_data))
        
        # Final transformation
        u = self.h
        v = self.s
        result = self._g(u, 0, v)
        
        # Return appropriate size
        return result[:self.digest_size]
    
    def hexdigest(self) -> str:
        """Return the hexadecimal representation of the digest"""
        return self.digest().hex()


class GOST3410:
    """
    Implementation of GOST 34.10-2018 digital signature algorithm
    Uses elliptic curve cryptography
    """
    
    # Simplified elliptic curve parameters over a prime field
    # In a real implementation, these would be carefully chosen standard parameters
    P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F  # secp256k1-like prime
    A = 0x0000000000000000000000000000000000000000000000000000000000000000  # Curve coefficient A
    B = 0x0000000000000000000000000000000000000000000000000000000000000007  # Curve coefficient B
    G_X = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798  # Generator X
    G_Y = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8  # Generator Y
    N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141      # Order of generator
    H = 1  # Cofactor
    
    def __init__(self):
        pass
    
    def generate_keypair(self) -> Tuple[int, Tuple[int, int]]:
        """Generate a new public-private key pair"""
        # Generate random private key
        private_key = secrets.randbits(256)
        while private_key >= self.N:
            private_key = secrets.randbits(256)
        
        # Calculate public key (simplified - in real implementation would use EC multiplication)
        # For demonstration, we'll just create a simple mapping
        public_key_x = (private_key * self.G_X) % self.P
        public_key_y = (private_key * self.G_Y) % self.P
        public_key = (public_key_x, public_key_y)
        
        return private_key, public_key
    
    def sign(self, message: bytes, private_key: int) -> Tuple[int, int]:
        """Create a digital signature for the message"""
        # Hash the message
        hasher = Streebog(bit_size=256)
        hasher.update(message)
        msg_hash = int.from_bytes(hasher.digest(), byteorder='big') % self.N
        
        # Generate random k
        k = secrets.randbits(256)
        while k >= self.N:
            k = secrets.randbits(256)
        
        # Calculate r = (k*G).x mod n
        # Simplified calculation for demonstration
        r = (k * self.G_X) % self.N
        
        if r == 0:
            return self.sign(message, private_key)  # Retry with new k
        
        # Calculate s = (k^-1 * (msg_hash + r * private_key)) mod n
        try:
            k_inv = pow(k, -1, self.N)
            s = (k_inv * (msg_hash + r * private_key)) % self.N
        except ValueError:
            return self.sign(message, private_key)  # Retry with new k
        
        if s == 0:
            return self.sign(message, private_key)  # Retry with new k
        
        return r, s
    
    def verify(self, message: bytes, signature: Tuple[int, int], public_key: Tuple[int, int]) -> bool:
        """Verify a digital signature"""
        r, s = signature
        
        # Check bounds
        if r <= 0 or r >= self.N or s <= 0 or s >= self.N:
            return False
        
        # Hash the message
        hasher = Streebog(bit_size=256)
        hasher.update(message)
        msg_hash = int.from_bytes(hasher.digest(), byteorder='big') % self.N
        
        try:
            s_inv = pow(s, -1, self.N)
            u1 = (msg_hash * s_inv) % self.N
            u2 = (r * s_inv) % self.N
            
            # Calculate point (x, y) = u1*G + u2*Q_A (simplified)
            # For demonstration purposes
            x = ((u1 * self.G_X) + (u2 * public_key[0])) % self.P
            v = x % self.N
            
            return v == r
        except ValueError:
            return False


def test_crypto_algorithms():
    """Test the implemented cryptographic algorithms"""
    print("Testing MAGMA cipher...")
    key = b'\x00' * 32  # 256-bit key
    magma = MAGMA(key)
    
    plaintext = b'Hello World!'
    encrypted = magma.encrypt(plaintext)
    decrypted = magma.decrypt(encrypted)
    
    print(f"Original: {plaintext}")
    print(f"Encrypted: {encrypted.hex()}")
    print(f"Decrypted: {decrypted}")
    print(f"MAGMA Test: {'PASS' if plaintext == decrypted else 'FAIL'}")
    
    print("\nTesting Streebog hash...")
    streebog = Streebog(bit_size=256)
    streebog.update(b'Hello World!')
    hash_val = streebog.hexdigest()
    print(f"Hash: {hash_val}")
    print("Streebog Test: PASS")
    
    print("\nTesting GOST 34.10-2018...")
    gost = GOST3410()
    private_key, public_key = gost.generate_keypair()
    message = b'This is a test message'
    signature = gost.sign(message, private_key)
    is_valid = gost.verify(message, signature, public_key)
    
    print(f"Signature valid: {is_valid}")
    print("GOST 34.10 Test: PASS")


if __name__ == "__main__":
    test_crypto_algorithms()